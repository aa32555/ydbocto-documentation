\documentclass[]{article}

\usepackage{listings}

\def\code#1{\texttt{#1}}

%opening
\title{Creating a SQL Engine for NoSQL Databases}
\author{Charles Hathaway, Narayanan Iyer, KS Bhaskar}

\begin{document}

\maketitle

\begin{abstract}
	
	There is plenty of research talking about specific details of implementing a SQL engine and query optimizer, but very little direction given for the more mundane task of actually creating one.
	Knowledge of the field of programming languages and databases systems is required to even begin the task, but each of those fields is so large that gaining a breadth of understanding can take years.
	In this paper, we explore the creation of Octo, a SQL engine designed to provide access to data already existing YottaDB datastores, such as the wealth information generated by user of the VistA EHR system.

\end{abstract}

\section{Introduction}

Octo maps data stored in M globals to a relational schema overlay using an augmented SQL DDL language.
The user is responsible for generating this DDL, and informing Octo about how to fetch specific columns and iterate through data in a table.
With these pieces of information, Octo can generate execution plans for a given SQL query, including JOINs, which return the data the user is looking for.
Octo uses a 3-phase architecture, consisting of parsing, logical plan generation and optimization, and physical plan generation and emittion.
Each of these phases is explored in detail in the following sections.

Throughout this document, we make use of examples referencing a sample schema.
This schema is intentionally very simple, allowing us to keep the sample queries and generated plans small and manageable.
Please see figure \ref{fig:intro_names_schema} for the source DDL, and figure \ref{fig:into_names_data} for the data we use when executing these queries.

Note that the GLOBAL keyword in figure \ref{fig:intro_names_schema} is explained in section \ref{sec:parsing}.
For now, just know that it is glue connecting the underlying M database to the relational schema.

\begin{figure}
	\lstinputlisting{figures/intro_names_schema.sql}
	\caption{Schema used throughout this paper for sample queries}
	\label{fig:intro_names_schema}
\end{figure}

\begin{figure}
	\lstinputlisting{figures/intro_names_data.zwr}
	\caption{Source data used for this paper; in YottaDB ZWR format}
	\label{fig:into_names_data}
\end{figure}

\section{Background Information}

\section{Parsing} \label{sec:parsing}

% We should write something describing M globals here

% prefix = lp_
\section{Logical Planning}

Logical planning is where a majority of the complexity of the SQL engine is located in this design; it includes things such as boolean expression expansion and reordering, converting JOIN's to a series of key iterations, transforming OUTER JOINs to a series of SET operations, and things of the like.

In Octo, logical planning first takes the data structures representing the parsed SQL query, and transforms it into a binary tree.
This binary tree is what we mean when we talk about the logical plan.
Later, optimizations are done on this tree which do things such as:

\begin{enumerate}
	\item Load keys from tables and insert them in a particular order to the 'keys' section of the logical plan
	\item Update keys to have specific advance techniques, such as fixing them to a particular value if we know the boolean condition of the query requires the key to have that value
	\item Replace keys with cross-reference keys if we can perform an optimization on a column other than a key column
	\item Normalize boolean expressions to we have no disjunctions, which would prevent other optimizations from taking place
\end{enumerate}

\subsection{Pre-optimization Logical Plans}

Before performing any optimizations, Octo converts the parsed SQL expression from the previous stage into a logical plan.
This logical plan is represented as a binary tree, where each element in the tree either has children, the type of children is dependent upon the type of element, and eventually terminates with a leaf node.
Consider figure \ref{fig:lp_before_optimizations} for an example of a logical plan.

\begin{figure}
	\lstinputlisting{figures/lp_before_optimization.yml}
	\caption{Logical plan without any optimizations performed. Source query: \texttt{select * from names;}}
	\label{fig:lp_before_optimizations}
\end{figure}

In this example, we can see the core structure of the base SELECT statement after it gets transformed.
Walking down this tree in a depth-first fashion, we can see:

\begin{itemize}
	\item At the top-level is a \code{LP\_INSERT}; this is meant to denote the semantic understanding that we are inserting data from the next \code{LP\_PROJECT} into a \code{LP\_OUTPUT}.
	\item \code{LP\_PROJECT}, which represents a relational projection of data. In addition to the column selection list, we also store data about criteria for the selection and the source of the selections.
	\item \code{LP\_COLUMN\_LIST} is a top-level items which will have a value/expression node on the left, and on the right another \code{LP\_COLUMN\_LIST} or a NULL value
	\item \code{LP\_WHERE} marks the beginning of an expression. Originally used only in the WHERE clause of the SQL expression, as Octo evolved it found use in many other places, including to represent expressions in the projection. Generally, the right-hand expression if a \code{LP\_WHERE} is allowed to be NULL, however, in some places it is overloaded to store additional information specific to the context; this is one such place, where we store the \code{LP\_COLUMN\_LIST\_ALIAS} description in the right node, and the expression in the left node
	\item \code{LP\_COLUMN\_ALIAS} is one of many nodes that can be part of an expression; specifically, \code{LP\_COLUMN\_ALIAS} refers to a column in one of the joined table, and is a leaf node that includes information such as table and column names
	\item \code{LP\_COLUMN\_LIST\_ALIAS} is stores information about how this column list should be referred to later in the plan, including in parent/children queries, within the WHERE/ORDER BY clauses, etc. It is a leaf node that contains an alias (column name) and type of the data item
	\item \code{LP\_SELECT} is a parent node which represents a 'select' criteria, including source tables and conditions of the selection
	\item \code{LP\_TABLE\_JOIN} has a table in the left node, and either NULL or a \code{LP\_TABLE\_JOIN} in the right join. Internally, this does include information about the conditions of the join, but they are not currently rendered in the logical plan
	\item \code{LP\_CRITERIA} contains information about the limitations of our table select, including boolean conditions. After being optimized, the left node will contain a list of keys which are used in physical selection of data from the database. The right node stores the options of the select
	\item \code{LP\_KEYS} is explained more in the description of the plan post-optimization.
	\item \code{LP\_SELECT\_OPTIONS} contains the boolean condition located in the WHERE clause of the select statement in the left node, and the right node might contain additional criteria (such as DISTINCT, LIMIT, GROUP BY, etc.)
	\item \code{LP\_OUTPUT} represents the output location of the parent \code{LP\_INSERT}, and in addition to a \code{LP\_KEY} which will eventually contain the final rowset, it also contains metadata about how the rowset is stored (as an index, as a series of keys rather than actual values, etc.)
\end{itemize}



\end{document}
