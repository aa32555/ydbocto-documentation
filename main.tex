\documentclass[]{article}

\usepackage{listings}
\usepackage{appendix}

\def\code#1{\texttt{#1}}

%opening
\title{Creating a SQL Engine for NoSQL Databases}
\author{Charles Hathaway, Jon Badiali, Narayanan Iyer, KS Bhaskar}

\begin{document}

\maketitle

\begin{abstract}
	
	There is plenty of research talking about specific details of implementing a SQL engine and query optimizer, but very little direction given for the more mundane task of actually creating one.
	Knowledge of the field of programming languages and databases systems is required to even begin the task, but each of those fields is so large that gaining a breadth of understanding can take years.
	In this paper, we explore the creation of Octo, a SQL engine designed to provide access to data already existing YottaDB datastores, such as the wealth information generated by user of the VistA EHR system.

\end{abstract}

\section{Introduction}

Octo maps data stored in M globals to a relational schema overlay using an augmented SQL DDL language.
The user is responsible for generating this DDL, and informing Octo about how to fetch specific columns and iterate through data in a table.
With these pieces of information, Octo can generate execution plans for a given SQL query, including JOINs, which return the data the user is looking for.
Octo uses a 3-phase architecture, consisting of parsing, logical plan generation and optimization, and physical plan generation and emittion.
Each of these phases is explored in detail in the following sections.

Throughout this document, we make use of examples referencing a sample schema.
This schema is intentionally very simple, allowing us to keep the sample queries and generated plans small and manageable.
Please see listing \ref{fig:intro_names_schema} for the source DDL, and listing \ref{fig:into_names_data} for the data we use when executing these queries.

Note that the GLOBAL keyword in listing \ref{fig:intro_names_schema} is explained in section \ref{sec:parsing}.
For now, just know that it is glue connecting the underlying M database to the relational schema.


\section{Background Information}

\section{Parsing} \label{sec:parsing}

% We should write something describing M globals here

% prefix = lp_
\section{Logical Planning}

Logical planning is where a majority of the complexity of the SQL engine is located in this design; it includes things such as boolean expression expansion and reordering, converting JOIN's to a series of key iterations, transforming OUTER JOINs to a series of SET operations, and things of the like.

In Octo, logical planning first takes the data structures representing the parsed SQL query, and transforms it into a binary tree.
This binary tree is what we mean when we talk about the logical plan.
Later, optimizations are done on this tree which do things such as:

\begin{enumerate}
	\item Load keys from tables and insert them in a particular order to the 'keys' section of the logical plan
	\item Update keys to have specific advance techniques, such as fixing them to a particular value if we know the boolean condition of the query requires the key to have that value
	\item Replace keys with cross-reference keys if we can perform an optimization on a column other than a key column
	\item Normalize boolean expressions to we have no disjunctions, which would prevent other optimizations from taking place
\end{enumerate}

\subsection{Pre-optimization Logical Plans}

Before performing any optimizations, Octo converts the parsed SQL expression from the previous stage into a logical plan.
This logical plan is represented as a binary tree, where each element in the tree either has children, the type of children is dependent upon the type of element, and eventually terminates with a leaf node.
It is during this phase that we:

\begin{itemize}
	\item Expand certain expressions to more normalized expressions
	\item Replace references to derived tables with references to their output keys
	\item Move JOIN conditions onto the WHERE condition
	\item Recurse into subplans to perform logical plan generation and optimization
\end{itemize}

Consider figure \ref{fig:lp_before_optimizations} for an example of a logical plan.

\begin{figure}
	\lstinputlisting{figures/lp_before_optimization.yml}
	\caption{Logical plan without any optimizations performed. Source query: \texttt{select * from names;}}
	\label{fig:lp_before_optimizations}
\end{figure}

In this example, we can see the core structure of the base SELECT statement after it gets transformed.
Walking down this tree in a depth-first fashion, we can see:

\begin{itemize}
	\item At the top-level is a \code{LP\_INSERT}; this is meant to denote the semantic understanding that we are inserting data from the next \code{LP\_PROJECT} into a \code{LP\_OUTPUT}.
	\item \code{LP\_PROJECT}, which represents a relational projection of data. In addition to the column selection list, we also store data about criteria for the selection and the source of the selections.
	\item \code{LP\_COLUMN\_LIST} is a top-level items which will have a value/expression node on the left, and on the right another \code{LP\_COLUMN\_LIST} or a NULL value
	\item \code{LP\_WHERE} marks the beginning of an expression. Originally used only in the WHERE clause of the SQL expression, as Octo evolved it found use in many other places, including to represent expressions in the projection. Generally, the right-hand expression if a \code{LP\_WHERE} is allowed to be NULL, however, in some places it is overloaded to store additional information specific to the context; this is one such place, where we store the \code{LP\_COLUMN\_LIST\_ALIAS} description in the right node, and the expression in the left node
	\item \code{LP\_COLUMN\_ALIAS} is one of many nodes that can be part of an expression; specifically, \code{LP\_COLUMN\_ALIAS} refers to a column in one of the joined table, and is a leaf node that includes information such as table and column names
	\item \code{LP\_COLUMN\_LIST\_ALIAS} is stores information about how this column list should be referred to later in the plan, including in parent/children queries, within the WHERE/ORDER BY clauses, etc. It is a leaf node that contains an alias (column name) and type of the data item
	\item \code{LP\_SELECT} is a parent node which represents a 'select' criteria, including source tables and conditions of the selection
	\item \code{LP\_TABLE\_JOIN} has a table in the left node, and either NULL or a \code{LP\_TABLE\_JOIN} in the right join. Internally, this does include information about the conditions of the join, but they are not currently rendered in the logical plan
	\item \code{LP\_CRITERIA} contains information about the limitations of our table select, including boolean conditions. After being optimized, the left node will contain a list of keys which are used in physical selection of data from the database. The right node stores the options of the select
	\item \code{LP\_KEYS} is explained more in the description of the plan post-optimization.
	\item \code{LP\_SELECT\_OPTIONS} contains the boolean condition located in the WHERE clause of the select statement in the left node, and the right node might contain additional criteria (such as DISTINCT, LIMIT, GROUP BY, etc.)
	\item \code{LP\_OUTPUT} represents the output location of the parent \code{LP\_INSERT}, and in addition to a \code{LP\_KEY} which will eventually contain the final rowset, it also contains metadata about how the rowset is stored (as an index, as a series of keys rather than actual values, etc.)
\end{itemize}

Appendix listing \ref{app:lp_action_types.hd} lists all types of logical plan items, along with annotations.
It is expected that additional items will be added as needed, and that the grammar used here will continue to evolve as additional needs are discovered.

\subsection{Optimized Logical Plans}

After the generated logical plan is verified for structure, the next stage in logical planning occurs; optimization.
In this stage, Octo:

\begin{itemize}
	\item Inserts all keys needed to iterate on all joined tables into the \code{LP\_KEYS} section of the logical plan
	\begin{itemize}
		\item At this point, the ordering of the keys should be done such that the keys with the largest number of rows come first, and the fewest last. This allows us to simplify heuristics later to select which optimizations take preference over others
	\end{itemize}
	\item Walks through the conditions in the \code{LP\_SELECT\_OPTIONS}, and:
	\begin{itemize}
		\item Identifies places where we can perform optimizations, and alters the plan as needed
		\item Reorders the boolean expression such that there are no longer any disjunctions, and instead all disjunctions are expanded into a normalized disjunctive form
	\end{itemize}
\end{itemize}

The task of inserting the keys into logical plan for iteration is one place where future development efforts in Octo may be directed; it allows one to use heuristics to prioritize the optimizations that occur later on.
Note that the use of these heurstics does not guarntee an optimal solution, and as a general case, this problem is one that does not have an answer.
It has been shown to be NP-complete \cite{cook_complexity_1971}, and it's been shown that plans which propagate error are only marginally better than random guesses \cite{ioannidis_propagation_1991}.
This assertion is based on the current state of Octo, in that it performs optimizations by iterating over the elements in the WHERE condition of the statement, and identifying expressions where at least one side of the expression can be 'fixed' to the other side.
In this context, fixing means adjusting the logical plan such that a particular \code{LP\_KEY} changes from a type of \code{LP\_KEY\_ADVANCE} to \code{LP\_KEY\_FIX}, and the value field is populated with a pointer to the value the key is fixed too.

In addition to fixing keys to values, we can also fix an arbitrary column to a value, and limit our iteration, using a cross index.
Octo will automatically generate the cross index for any column it wants to use for an optimization.
This results in a \code{LP\_KEY} being replaced with two \code{LP\_KEY}s, one of which will be fixed, and the other of which will iterate through all keys under a fixed value in the cross reference.
Section \ref{sec:lp_xref_keys} goes into more details about how the cross reference is organized.

It is important to note that it is not possible to perform \code{LP\_KEY\_FIX} optimizations on conditions which contain a disjunction.
Consider the boolean expression:

$lastName = "Cool"\ AND\ (firstName = "Zero"\ OR\ lastName = "Burn")$.

It is obvious that we can not fix firstName to "Zero" in this case, since it would mean we can't ever match lastName = "Burn".
To solve this problem, we convert the expression to normal disjunctive form.
This results in an expression that looks like:

$(lastName = "Cool"\ AND\ firstName = "Zero")\ OR\ (lastName = "Cool"\ AND\ lastName = "Burn")$.

We are then able to split the expression apart, and construct a new logical plan which contains the UNION ALL of the two sets.
Some care has to be taken to avoid matching rows which will be true for multiple subsets of the boolean expression, but would have only resulted in one row if we had not split the statement apart.
Octo does in the physical planning phase by tracking which values of keys have matched a row, and only inserting data to the output key if we have not seen that combination of keys before.
This is discussed in more detail in section \ref{sec:physical}.

The example given here as an additional interesting characteristic; the second term of the expanded form will never be true.
There can not be a case where lastName is equal to "Cool" and lastName is equal to "Burn".
The entire boolean term could be dropped, saving us the work of iterating over some amount of the table looking for a case where both statements are true.
Octo does not yet do this type of boolean optimization, and will likely rely on an open source solution to solve it.
This problem is the NP-complete problem generally accepted as the boolean satisfaction problem, and discussed in many computer science works \cite{cook_complexity_1971}.

\subsubsection{Cross Reference Keys} \label{sec:lp_xref_keys}

Octo generates cross references to assist with performing optimization on columns which aren't keys, and aren't normally involved in iterating over the table.
It does this by constructing a new value in the database, with the form described in listing \ref{fig:lp_lastname_xref}.

The global name, \code{\%ydbocroxref}, followed by the name of the table the cross reference is for.
After that comes the name of the column within that table.
The value of this node is total count of the rows in the table.
Next, for each unique value of that column within the table, we have a node with the total number of rows which match that column value.
The children for each of those nodes will contain all components of tables key, which in the sample names table is a single column of an integer type.

Using this organization, we can iterate on all nodes with a particular value for a column rather than iterate through all rows in the table to identify those which have the column value in question.

\lstinputlisting[
caption={Sample Cross Reference Keys},
label=fig:lp_lastname_xref]
{figures/lp_lastname_xref.zwr}

\subsubsection{Related Source Files}

The source files in Octo related to this phase are located under \code{src/optimization\_transforms/}, the most important files being:

\begin{itemize}
	\item \code{src/optimization\_transforms/logical\_plan.h}
	\item \code{src/optimization\_transforms/optimize\_logical\_plan.c}
	\item \code{src/optimization\_transforms/lp\_make\_normal\_disjunctive\_form.c}
	\item \code{src/optimization\_transforms/lp\_opt\_fix\_key\_to\_const.c}
	\item \code{src/optimization\_transforms/lp\_optimize\_where\_multi\_equals\_ands.c}
	\item \code{src/optimization\_transforms/lp\_generate\_xref\_keys.c}
\end{itemize}

\section{Physical Planning} \label{sec:physical}

\appendix
\appendixpage
\addappheadtotoc

\section{Sample Schema and Data}

\lstinputlisting[
	caption={Schema used throughout this paper for sample queries},
	label=fig:intro_names_schema]
{figures/intro_names_schema.sql}

\lstinputlisting[
	caption={Source data used for this paper; in YottaDB ZWR format},
	label=fig:into_names_data]
{figures/intro_names_data.zwr}

\section{Logical Plan Action Types}

\lstinputlisting[caption={Annotated logical plan action types},label=app:lp_action_types.hd]{figures/lp_action_type.hd}

\bibliographystyle{unsrt}
\bibliography{biblo}

\end{document}
